<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>GeoShooter – Twin‑Stick Arena</title>
  <style>
    html,body{margin:0;padding:0;background:#000;overflow:hidden}
    canvas{display:block;margin:0 auto;background:#000}
    #ui{position:absolute;top:10px;left:10px;color:#0f0;font-family:monospace;font-size:14px;z-index:10;user-select:none}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">Score: <span id="score">0</span> &nbsp;Lives: <span id="lives">3</span></div>
<script>
// ===== Utility =====
class Vec2{constructor(x,y){this.x=x;this.y=y}add(v){return new Vec2(this.x+v.x,this.y+v.y)}sub(v){return new Vec2(this.x-v.x,this.y-v.y)}mul(s){return new Vec2(this.x*s,this.y*s)}len(){return Math.hypot(this.x,this.y)}norm(){const l=this.len();return l?this.mul(1/l):new Vec2(0,0)}}

// ===== Canvas & Globals =====
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
function resize(){canvas.width=window.innerWidth;canvas.height=window.innerHeight}
window.addEventListener("resize",resize);resize();

// Keyboard state
const keys={};
window.addEventListener("keydown",e=>keys[e.code]=true);
window.addEventListener("keyup",e=>keys[e.code]=false);

// Gamepad state
let gpIndex=null;
window.addEventListener("gamepadconnected",e=>{if(gpIndex===null){gpIndex=e.gamepad.index}});
window.addEventListener("gamepaddisconnected",e=>{if(e.gamepad.index===gpIndex)gpIndex=null});
function readGamepad(){if(gpIndex===null)return null;const gp=navigator.getGamepads()[gpIndex];return gp&&gp.connected?gp:null}

// ===== Particle System =====
class Particle{constructor(pos,vel,life,color){this.pos=pos;this.vel=vel;this.life=life;this.color=color}
 update(dt){this.pos=this.pos.add(this.vel.mul(dt));this.life-=dt}
 draw(){ctx.fillStyle=this.color;ctx.globalAlpha=Math.max(this.life/0.6,0);ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,2,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1}}

function spawnBurst(pos,color){for(let i=0;i<16;i++){const angle=Math.random()*Math.PI*2;const speed=50+Math.random()*150;const v=new Vec2(Math.cos(angle),Math.sin(angle)).mul(speed);particles.push(new Particle(pos,v,0.6,color))}}

// ===== Entities =====
class Bullet{constructor(pos,vel){this.pos=pos;this.vel=vel;this.r=4}
 update(dt){this.pos=this.pos.add(this.vel.mul(dt))}
 draw(){ctx.fillStyle="#fff";ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.r,0,Math.PI*2);ctx.fill()}
 offScreen(){return this.pos.x<-10||this.pos.x>canvas.width+10||this.pos.y<-10||this.pos.y>canvas.height+10}}

class Enemy{constructor(pos,vel){this.pos=pos;this.vel=vel;this.r=12}
 update(dt){this.pos=this.pos.add(this.vel.mul(dt));if(this.pos.x<0||this.pos.x>canvas.width)this.vel.x*=-1;if(this.pos.y<0||this.pos.y>canvas.height)this.vel.y*=-1}
 draw(){ctx.strokeStyle="#f0f";ctx.lineWidth=2;ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.r,0,Math.PI*2);ctx.stroke()}}

class Player{constructor(){this.pos=new Vec2(canvas.width/2,canvas.height/2);this.speed=250;this.r=10;this.fireRate=0.15;this.cd=0}
 update(dt){let dir=new Vec2(0,0);
   // Keyboard movement WASD
   if(keys["KeyW"])dir=dir.add(new Vec2(0,-1));
   if(keys["KeyS"])dir=dir.add(new Vec2(0,1));
   if(keys["KeyA"])dir=dir.add(new Vec2(-1,0));
   if(keys["KeyD"])dir=dir.add(new Vec2(1,0));
   // Gamepad left stick
   const gp=readGamepad();
   if(gp){const ax=gp.axes[0],ay=gp.axes[1];if(Math.hypot(ax,ay)>0.2)dir=dir.add(new Vec2(ax,ay))}
   if(dir.x||dir.y)this.pos=this.pos.add(dir.norm().mul(this.speed*dt));
   this.pos.x=Math.max(0,Math.min(canvas.width,this.pos.x));
   this.pos.y=Math.max(0,Math.min(canvas.height,this.pos.y));
   // Shooting
   if(this.cd>0)this.cd-=dt;
   let sdir=new Vec2(0,0);
   // Keyboard arrows
   if(keys["ArrowUp"])sdir=sdir.add(new Vec2(0,-1));
   if(keys["ArrowDown"])sdir=sdir.add(new Vec2(0,1));
   if(keys["ArrowLeft"])sdir=sdir.add(new Vec2(-1,0));
   if(keys["ArrowRight"])sdir=sdir.add(new Vec2(1,0));
   // Gamepad right stick (axes 2,3)
   if(gp){const ax=gp.axes[2],ay=gp.axes[3];if(Math.hypot(ax,ay)>0.25)sdir=sdir.add(new Vec2(ax,ay))}
   if((sdir.x||sdir.y)&&this.cd<=0){bullets.push(new Bullet(this.pos.add(sdir.norm().mul(this.r+4)),sdir.norm().mul(450)));this.cd=this.fireRate}
 }
 draw(){ctx.fillStyle="#0f0";ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.r,0,Math.PI*2);ctx.fill()}}

// ===== Game State =====
let player,bullets,enemies,particles,spawnTimer,score,lives,lastTs;
function reset(){player=new Player();bullets=[];enemies=[];particles=[];spawnTimer=0;score=0;lives=3;updateUI()}
function updateUI(){document.getElementById("score").textContent=score;document.getElementById("lives").textContent=lives}
function spawnEnemy(){const edge=Math.floor(Math.random()*4);let pos,vel;switch(edge){case 0:pos=new Vec2(Math.random()*canvas.width,0);vel=new Vec2((Math.random()-0.5)*100,50+Math.random()*100);break;case 1:pos=new Vec2(canvas.width,Math.random()*canvas.height);vel=new Vec2(-50-Math.random()*100,(Math.random()-0.5)*100);break;case 2:pos=new Vec2(Math.random()*canvas.width,canvas.height);vel=new Vec2((Math.random()-0.5)*100,-50-Math.random()*100);break;default:pos=new Vec2(0,Math.random()*canvas.height);vel=new Vec2(50+Math.random()*100,(Math.random()-0.5)*100)}enemies.push(new Enemy(pos,vel))}

function gameOverScreen(){ctx.fillStyle="rgba(0,0,0,0.8)";ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle="#f00";ctx.font="48px sans-serif";ctx.textAlign="center";ctx.fillText("GAME OVER",canvas.width/2,canvas.height/2);ctx.font="24px sans-serif";ctx.fillText("Press R / Start to Restart",canvas.width/2,canvas.height/2+40)}

function update(dt){player.update(dt);bullets.forEach(b=>b.update(dt));enemies.forEach(e=>e.update(dt));particles.forEach(p=>p.update(dt));
 // collisions bullet-enemy
 outer:for(let i=enemies.length-1;i>=0;i--){const e=enemies[i];for(let j=bullets.length-1;j>=0;j--){const b=bullets[j];if(e.pos.sub(b.pos).len()<e.r+b.r){enemies.splice(i,1);bullets.splice(j,1);score+=10;updateUI();spawnBurst(e.pos,"#f0f");continue outer}}if(player.pos.sub(e.pos).len()<e.r+player.r){enemies.splice(i,1);lives--;updateUI();spawnBurst(player.pos,"#f00");if(lives<=0)return false}}
 bullets=bullets.filter(b=>!b.offScreen());particles=particles.filter(p=>p.life>0);
 spawnTimer-=dt;if(spawnTimer<=0){spawnEnemy();spawnTimer=Math.max(0.2,0.5-score/2000)}return true}

function draw(){ctx.clearRect(0,0,canvas.width,canvas.height);particles.forEach(p=>p.draw());player.draw();bullets.forEach(b=>b.draw());enemies.forEach(e=>e.draw())}

function loop(ts){const dt=(ts-lastTs)/1000;lastTs=ts;if(update(dt)){draw();requestAnimationFrame(loop)}else{draw();gameOverScreen()}}

window.addEventListener("keydown",e=>{if(e.code==="KeyR"&&lives<=0){reset();lastTs=performance.now();requestAnimationFrame(loop)}});
function pollStartButton(){const gp=readGamepad();if(lives<=0&&gp&&gp.buttons[9].pressed){reset();lastTs=performance.now();requestAnimationFrame(loop)}requestAnimationFrame(pollStartButton)}

// bootstrap
reset();lastTs=performance.now();requestAnimationFrame(loop);pollStartButton();
</script>
</body>
</html>
